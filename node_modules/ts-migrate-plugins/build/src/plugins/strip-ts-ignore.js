"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-use-before-define, @typescript-eslint/no-use-before-define */
const typescript_1 = __importDefault(require("typescript"));
const updateSourceText_1 = __importDefault(require("../utils/updateSourceText"));
const stripTSIgnorePlugin = {
    name: 'strip-ts-ignore',
    run({ text, fileName }) {
        const sourceFile = typescript_1.default.createSourceFile(fileName, text, typescript_1.default.ScriptTarget.Latest);
        return getTextWithoutIgnores(sourceFile);
    },
};
exports.default = stripTSIgnorePlugin;
function getTextWithoutIgnores(sourceFile) {
    const updates = [];
    const printerWithoutComments = typescript_1.default.createPrinter({ removeComments: true });
    const printWithoutComments = (node) => printerWithoutComments.printNode(typescript_1.default.EmitHint.Unspecified, node, sourceFile);
    const { text } = sourceFile;
    const regExp = /(\/\/|\/\*) *@ts-(?:ignore|expect-error)\b/g;
    let result;
    // eslint-disable-next-line no-cond-assign
    while ((result = regExp.exec(text)) != null) {
        const matchPos = result.index;
        const { line } = typescript_1.default.getLineAndCharacterOfPosition(sourceFile, matchPos);
        const lineStart = typescript_1.default.getPositionOfLineAndCharacter(sourceFile, line, 0);
        const lineEnd = typescript_1.default.getPositionOfLineAndCharacter(sourceFile, line + 1, 0);
        const lineText = sourceFile.text.slice(lineStart, lineEnd);
        const node = findNodeAtPos(sourceFile, matchPos);
        if (node && !typescript_1.default.isJsxText(node)) {
            const commentRanges = getCommentRanges(text, node.pos).filter((range) => isInRange(matchPos, range));
            if (commentRanges.length > 0) {
                commentRanges.forEach((range) => {
                    const { pos, end } = expandToWhitespace(text, range);
                    updates.push({ kind: 'delete', index: pos, length: end - pos });
                });
            }
            else {
                const printedWithoutComments = printWithoutComments(node);
                const inTemplate = typescript_1.default.isTemplateLiteralToken(node);
                if (typescript_1.default.isJsxExpression(node) && printedWithoutComments === '') {
                    const { pos, end } = expandToWhitespace(text, node);
                    updates.push({ kind: 'delete', index: pos, length: end - pos });
                }
                else if (!inTemplate && /^ *\/\/ *@ts-(?:ignore|expect-error)\b/.test(lineText)) {
                    updates.push({ kind: 'delete', index: lineStart, length: lineEnd - lineStart });
                }
            }
        }
    }
    return updateSourceText_1.default(text, updates);
}
function findNodeAtPos(sourceFile, pos) {
    const visitor = (node) => typescript_1.default.forEachChild(node, visitor) || (isInRange(pos, node) ? node : undefined);
    return typescript_1.default.forEachChild(sourceFile, visitor);
}
function isInRange(pos, range) {
    return range.pos <= pos && pos < range.end;
}
function expandToWhitespace(text, range) {
    let { pos } = range;
    while (pos > 0 && text[pos - 1] === ' ') {
        pos -= 1;
    }
    let { end } = range;
    if (end < text.length && text[end] === typescript_1.default.sys.newLine) {
        end += 1;
    }
    return { pos, end };
}
function getCommentRanges(text, pos) {
    return [
        ...(typescript_1.default.getLeadingCommentRanges(text, pos) || []),
        ...(typescript_1.default.getTrailingCommentRanges(text, pos) || []),
    ];
}
//# sourceMappingURL=strip-ts-ignore.js.map