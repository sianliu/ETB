"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-bitwise */
const typescript_1 = __importDefault(require("typescript"));
const ts_migrate_server_1 = require("ts-migrate-server");
const validateOptions_1 = require("../utils/validateOptions");
const accessibility = ['private', 'protected', 'public'];
const optionProperties = {
    defaultAccessibility: { enum: accessibility },
    privateRegex: { type: 'string' },
    protectedRegex: { type: 'string' },
    publicRegex: { type: 'string' },
};
const memberAccessibilityPlugin = {
    name: 'member-accessibility',
    run({ sourceFile, text, options }) {
        const result = typescript_1.default.transform(sourceFile, [memberAccessibilityTransformerFactory(options)]);
        const newSourceFile = result.transformed[0];
        if (newSourceFile === sourceFile) {
            return text;
        }
        const printer = typescript_1.default.createPrinter();
        return printer.printFile(newSourceFile);
    },
    validate(options) {
        const valid = validateOptions_1.validateOptions(options, optionProperties);
        if (valid) {
            // Validate regex property syntax.
            // This can't be covered by JSON schema.
            const validOptions = options;
            accessibility.forEach((accessibility) => {
                const key = `${accessibility}Regex`;
                const value = validOptions[key];
                if (value) {
                    try {
                        RegExp(value);
                    }
                    catch (e) {
                        throw new ts_migrate_server_1.PluginOptionsError(`${key}: ${e.message}`);
                    }
                }
            });
        }
        return true;
    },
};
exports.default = memberAccessibilityPlugin;
const accessibilityMask = typescript_1.default.ModifierFlags.Private | typescript_1.default.ModifierFlags.Protected | typescript_1.default.ModifierFlags.Public;
const memberAccessibilityTransformerFactory = (options) => (context) => {
    const { factory } = context;
    let defaultAccessibility;
    switch (options.defaultAccessibility) {
        case 'private':
            defaultAccessibility = typescript_1.default.ModifierFlags.Private;
            break;
        case 'protected':
            defaultAccessibility = typescript_1.default.ModifierFlags.Protected;
            break;
        case 'public':
            defaultAccessibility = typescript_1.default.ModifierFlags.Public;
            break;
        default:
            defaultAccessibility = 0;
            break;
    }
    const privateRegex = options.privateRegex ? new RegExp(options.privateRegex) : null;
    const protectedRegex = options.protectedRegex ? new RegExp(options.protectedRegex) : null;
    const publicRegex = options.publicRegex ? new RegExp(options.publicRegex) : null;
    if (defaultAccessibility === 0 && !privateRegex && !protectedRegex && !publicRegex) {
        // Nothing to do. Don't bother traversing the AST.
        return (file) => file;
    }
    return (file) => typescript_1.default.visitNode(file, visit);
    function visit(origNode) {
        const node = typescript_1.default.visitEachChild(origNode, visit, context);
        if (typescript_1.default.isClassElement(node) &&
            typescript_1.default.isClassLike(node.parent) &&
            node.name &&
            typescript_1.default.isIdentifier(node.name)) {
            const modifierFlags = typescript_1.default.getCombinedModifierFlags(node);
            if ((modifierFlags & accessibilityMask) !== 0) {
                // Don't overwrite existing modifier.
                return node;
            }
            const name = node.name.text;
            let accessibilityFlag = defaultAccessibility;
            if (privateRegex === null || privateRegex === void 0 ? void 0 : privateRegex.test(name)) {
                accessibilityFlag = typescript_1.default.ModifierFlags.Private;
            }
            else if (protectedRegex === null || protectedRegex === void 0 ? void 0 : protectedRegex.test(name)) {
                accessibilityFlag = typescript_1.default.ModifierFlags.Protected;
            }
            else if (publicRegex === null || publicRegex === void 0 ? void 0 : publicRegex.test(name)) {
                accessibilityFlag = typescript_1.default.ModifierFlags.Public;
            }
            const modifiers = factory.createNodeArray(factory.createModifiersFromModifierFlags(modifierFlags | accessibilityFlag));
            switch (node.kind) {
                case typescript_1.default.SyntaxKind.PropertyDeclaration: {
                    const propertyNode = node;
                    return factory.updatePropertyDeclaration(propertyNode, propertyNode.decorators, modifiers, propertyNode.name, propertyNode.questionToken, propertyNode.type, propertyNode.initializer);
                }
                case typescript_1.default.SyntaxKind.MethodDeclaration: {
                    const methodNode = node;
                    return factory.updateMethodDeclaration(methodNode, methodNode.decorators, modifiers, methodNode.asteriskToken, methodNode.name, methodNode.questionToken, methodNode.typeParameters, methodNode.parameters, methodNode.type, methodNode.body);
                }
                case typescript_1.default.SyntaxKind.GetAccessor: {
                    const accessorNode = node;
                    return factory.updateGetAccessorDeclaration(accessorNode, accessorNode.decorators, modifiers, accessorNode.name, accessorNode.parameters, accessorNode.type, accessorNode.body);
                }
                case typescript_1.default.SyntaxKind.SetAccessor: {
                    const accessorNode = node;
                    return factory.updateSetAccessorDeclaration(accessorNode, accessorNode.decorators, modifiers, accessorNode.name, accessorNode.parameters, accessorNode.body);
                }
                default:
                    // Should be impossible.
                    return node;
            }
        }
        return node;
    }
};
//# sourceMappingURL=member-accessibility.js.map