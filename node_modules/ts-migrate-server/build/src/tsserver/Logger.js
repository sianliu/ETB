"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoopLogger = exports.FileLogger = exports.Msg = exports.LogLevel = void 0;
/* eslint-disable no-use-before-define, @typescript-eslint/no-use-before-define, class-methods-use-this */
/**
 * Modeled after https://github.com/Microsoft/TypeScript/blob/bb1ac81bb1ddab587e0a4c80c882b308268f7fc0/src/tsserver/server.ts#L120
 */
const fs_1 = __importDefault(require("fs"));
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["terse"] = 0] = "terse";
    LogLevel[LogLevel["normal"] = 1] = "normal";
    LogLevel[LogLevel["requestTime"] = 2] = "requestTime";
    LogLevel[LogLevel["verbose"] = 3] = "verbose";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
var Msg;
(function (Msg) {
    Msg["Err"] = "Err";
    Msg["Info"] = "Info";
    Msg["Perf"] = "Perf";
})(Msg = exports.Msg || (exports.Msg = {}));
class FileLogger {
    constructor(logFilename, traceToConsole, level) {
        this.fd = -1;
        this.seq = 0;
        this.inGroup = false;
        this.firstInGroup = true;
        this.logFilename = logFilename;
        this.traceToConsole = traceToConsole;
        this.level = level;
        try {
            this.fd = fs_1.default.openSync(logFilename, 'w');
        }
        catch (_) {
            // swallow the error and keep logging disabled if file cannot be opened
        }
    }
    close() {
        if (this.fd >= 0) {
            fs_1.default.close(this.fd, noop);
        }
    }
    getLogFileName() {
        return this.logFilename;
    }
    perftrc(s) {
        this.msg(s, Msg.Perf);
    }
    info(s) {
        this.msg(s, Msg.Info);
    }
    err(s) {
        this.msg(s, Msg.Err);
    }
    startGroup() {
        this.inGroup = true;
        this.firstInGroup = true;
    }
    endGroup() {
        this.inGroup = false;
    }
    loggingEnabled() {
        return !!this.logFilename || this.traceToConsole;
    }
    hasLevel(level) {
        return this.loggingEnabled() && this.level >= level;
    }
    msg(s, type = Msg.Err) {
        if (!this.canWrite)
            return;
        s = `[${nowString()}] ${s}\n`;
        if (!this.inGroup || this.firstInGroup) {
            const prefix = padStringRight(`${type} ${this.seq}`, '          ');
            s = prefix + s;
        }
        this.write(s);
        if (!this.inGroup) {
            this.seq += 1;
        }
    }
    get canWrite() {
        return this.fd >= 0 || this.traceToConsole;
    }
    write(s) {
        if (this.fd >= 0) {
            const buf = bufferFrom(s);
            fs_1.default.writeSync(this.fd, buf, 0, buf.length, /* position */ null);
        }
        if (this.traceToConsole) {
            // eslint-disable-next-line no-console
            console.warn(s);
        }
    }
}
exports.FileLogger = FileLogger;
class NoopLogger {
    close() {
        /* noop */
    }
    hasLevel(_level) {
        return false;
    }
    loggingEnabled() {
        return false;
    }
    perftrc(_s) {
        /* noop */
    }
    info(_s) {
        /* noop */
    }
    err(_s) {
        /* noop */
    }
    startGroup() {
        /* noop */
    }
    endGroup() {
        /* noop */
    }
    msg(_s, _type) {
        /* noop */
    }
    getLogFileName() {
        return undefined;
    }
}
exports.NoopLogger = NoopLogger;
function nowString() {
    // E.g. "12:34:56.789"
    const d = new Date();
    return `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}.${d.getMilliseconds()}`;
}
function padStringRight(str, padding) {
    return (str + padding).slice(0, padding.length);
}
function noop(_) { }
function bufferFrom(input, encoding) {
    return Buffer.from && Buffer.from !== Int8Array.from
        ? Buffer.from(input, encoding)
        : new Buffer(input, encoding); // eslint-disable-line no-buffer-constructor
}
//# sourceMappingURL=Logger.js.map